In this folder, I will keep track of the progress I make through Bluefever Software's VICE youtube tutorial series, comparing and contrasting it to the process of making my own engine in c++. I likely won't update this folder with regards to any upgrades or alterations I may make to the engine.

Day One: September 11, 2020. Lessons 1 - 16

From just the first few videos in the series, I can immediately tell that coding a chess engine in JavaScript is stylistically a much better choice than c++, at least for my level. In c++, I spent an immeasurable amount of time dealing with the headache of memory allocation, pointers, and all of the other yucky stuff c++ is infamous for. Additionally, JS is supported in browser, whereas in c++ I had to build an executable if I wanted to distribute it. Ostensibly, a chess engine in c++ should run faster than in JS. However, as my engine was my first experience with chess programming, suffice to say that gaining a few milliseconds per operation did not greatly impact my engine's performance.

For reference, my engine performed at around 1400 elo, whereas Bluefever Software's (who I shall refer to as BFS, the name of his engine is VICE) engine performed at around 2300 elo.

It is important to note that BFS's tutorials are from 2013, so he uses ES5 JavaScript, whereas I use ES6. Also, he used JQuery v1.10.1, while I used the latest version available, JQuery v3.5.1.

BFS starts out by explaining how he would represent the chess board, not as an 8 x 8 2D array, as I had used, but as a 120 element 1D array. This is probably the only aspect of VICE that I have a real problem with, it seems like clunky notation and unnecessary elements that will never be accessed. To make things even more confusing, he ALSO has an array of size 64, whose elements hold the mapped squares of a sub-array of 64 elements in the size-120 board array that represent the only elements that will be accessed. (He does this so we only have to iterate through 64 out of the 120 elements). He also has two functions that convert between the 64 and 120 array. His reasoning for why a 120 array is better than a 64 array is interesting, and solves an elegant problem in legal move generation for "sliding" pieces, but I'm not entirely convinced that it justifies the complexity.

I am a big fan of how BFS devotes a lot of time rigorously defining what makes a board unique, and his section on FEN strings. His solutions, which are probably standard practices in mainstream chess programming that I was not aware of, are pretty darn elegant. For example, he represents every combination of castling rights as a 4 bit binary integer, where each entry describes if a king of a given color can castle a given direction (2 colors * 2 directions = 4). To contrast, I created the board representation, and even legal move generation far before I did any work with castling rights, resulting in some very ugly code. BFS has been programming chess engines for 10 years, so while I tried to be thorough in my research before I started coding, there are some things that you can only really know from experience.

BFS subtly introduces the Zobrist hashing scheme early, in his board string representation  section, where he instructs us to fill 14 * 120 (numPieces * numSquares) worth of 31-bit memory (we use 31-bit numbers) with random numbers, and XORing them all together (along with side, castling rights, en passant) to create a unique board key. I am a bit confused, however, because this scheme could still lead to collisions, which seems like it would render the whole scheme invalid, but perhaps he simply relies on the sheer improbability of that happening?

Finally, I really like BFS's heavy use of constant object literals, it greatly improves the readability of his code.