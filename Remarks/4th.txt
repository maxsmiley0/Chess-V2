Day 4: September 14, 2020 39 - 48

This section of the tutorial focused on the search algorithm - sans improvements like the killer heuristic, and move ordering, which will come in the next part. The general concepts introduced were the minimax / negamax scheme, alpha beta pruning, iterative deepening, principal variation table, and quiescence search with standing pat. 

This part also introduced the evaluation function, which simply counted the material differential, along with a piece square table.

For the most part, the search function of VICE was pretty similar to that of my c++ engine. I used the minimax formula with the alpha beta improvement. The use of negamax was interesting - it cut down a lot of repetitive code to handle differences in the side of the color to move. As of now, BFS has yet to implement a transposition table, which surprises me, because it is typically considered one of the easiest and biggest improvements to make. Both of our engines use the iterative deepening framework. This was the first time I properly implemented quiescence search, my engine evaluation simply recommended against capturing lower valued pieces with higher valued pieces to mitigate the horizon effect. 

BFS's use of the principal variation table was very educational, my program simply kept track of the best move, and not the line that would follow that move. I am slightly confused as to how collisions would be handled in the PV Table, as it only has 10,000 entries, and its elements are indexed by the board state number modulo 10,000. Obviously, there are more than 10 thousand possible board states.

The biggest time saver of VICE's search algorithm was its move ordering. My program simply ordered moves by calling the static eval on all immediate possible board states, and then searching those lines deeper.

First, the engine would search the principal variation move found from the previous iteration at a lower depth, if such a move existed. Then, it would search the captures using the MVVLVA principal, meaning the captures with the most valuable victims would be searched first (e.g. all moves involving rook captures before knight captures). Within this parameter, the captures would be ordered by the least valuable attacker (e.g. pawn capturing a rook would be searched before knight capturing a rook). Next, we searched the two most recent killer moves, e.g. moves that produced beta cutoffs. The principal behind searching these moves is that if it was good enough to create a beta cutoff in a similar, yet slightly different position, it is likely to also be good in the current position. Finally, we search the remaining quiet moves by ordering them through their history heuristic, the alpha value they were assigned in previous iterations. 